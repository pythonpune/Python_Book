\documentclass[letterpaper,12pt]{book}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{geometry}

\renewcommand{\familydefault}{Ubuntu}
 
\lstset{%
  basicstyle=\ttfamily,
  language=[LaTeX]{TeX},
}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{red},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{black},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=blue,
    urlcolor=black}

\usepackage{marginnote}
\usepackage[bottom]{footmisc}
\begin{document}
\tableofcontents
\part{Introduction to Python3}

\chapter{Getting started with Python3}

\section{Python3 Interpretor}
If you are new to Python then we will suggest you should start with any Linux OS, it will give you more scope to design the program and other tools. In this tutorial I'm using Fedora Linux to teach you how to start with \texttt{Python3}. Basically Python language is developed in C language. Python is one of the easy language to learn and you can start with it easily.
Let's get started with Python3 interpretor. You need to type \texttt{python3} in to your interpreter and you are here.

\begin{lstlisting}
$ python3
Python 3.7.0 (default, Sep 10 2018, 16:52:22) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
\end{lstlisting}
\subsection{Operators}
As I mentioned, Python is interpreted language, you will give input to it and it will give you output instantly.

You can start with additions of numbers.
\begin{lstlisting}
>>> 10 + 20
30
>>> 30 - 10
20
>>> 10 * 2
20
>>> 10 / 2
5.0
>>> 10 // 2
5
>>> 10 % 2
0
>>> 
\end{lstlisting}
In above example you could see that as soon as the input is given, Python interpreter is giving output.

\paragraph{}
In Python // operator have special meaning. It will return you the absolute result, while / operator will return result in the float.

\subsection{Relational Operators}
In python you can directly compare two numbers, Python interpreter provide functionality to compare two numbers which most of the language do not provide.

For more clarification see the following examples:
\begin{lstlisting}
>>> 10 == 10
True
>>> 10 > 10
False
>>> 10 < 10
False
>>> 10 <= 10
True
>>> 10 >= 10
True
>>> 10 != 10
False
\end{lstlisting}

\subsection{Bitwise Operators}
Bitwise operators are used to perform bit operations on the numbers. Those numbers are treated as string of bits written in twos complement binary.
\begin{itemize}
	\item 0 is written as "0"
	\item 1 is written as "1"
	\item 2 is written as "10"
	\item 3 is "11"
	\item .
	\item .
	\item 1029 is  ``10000000101" == 2**10 + 2**2 + 2**0 == 1024 + 4 + 1
\end{itemize}

\subsubsection{Operators}
\begin{itemize}
	\item $x \ll y$ : $x$ operator is shifted to left by $y$ bits and it return result of $x$ with shifted $y$ bits. It is same as $x * 2 ** y$
	      \begin{lstlisting}
>>> 3<<2
12
>>> 3*2**2
12
\end{lstlisting}
	\item $x \gg y$ : $x$ operator is shifted to right by $y$ bits and it return result of $x$ with shifted $y$ bits. It is same as $x // 2 ** y$.
	      \begin{lstlisting}
>>> 8>>2
2
>>> 8//2**2
2
\end{lstlisting}
	\item $x \& y $: Bitwise AND, each bit of output is 1 if corresponding bit of $x$ AND $y$ is 1, otherwise it is 0
	      \begin{lstlisting}
>>> 8 & 8
8
>>> 8 & 2
0
\end{lstlisting}
	\item $x | y$ : Bitwise OR, each bit of output is 1 if corresponding bit of $x$ AND $y$ is 1, otherwise it is 0
	      \begin{lstlisting}
>>> 2 | 2
2
>>> 2 | 4
6
>>> 
\end{lstlisting}
	\item $\sim x $: Complement, It will gives complement of $x$, the number you get by switching each 1 for a 0 and each 0 for a 1. This is the same as -x - 1.
	      \begin{lstlisting}
>>> ~2
-3
\end{lstlisting}
	\item $x \wedge y$ :  Does a ``bitwise exclusive or". Each bit of the output is the same as the corresponding bit in $x$ if that bit in $y$ is 0, and it's the complement of the bit in $x$ if that bit in $y$ is 1.
	      \begin{lstlisting}
>>> 1^1
0
>>> 1^2
3
\end{lstlisting}
\end{itemize}

\subsection{Keywords}

In any programming language keywords are present, those are nothing but reserve words. You can not use those words for any variable assignment or for function deceleration.

List of keywords present in the Python\\
\begin{center}
	\begin{tabular}{llll}
		class    & False  & None    & True   \\
		and      & as     & assert  & break  \\
		continue & def    & del     & elif   \\
		else     & expect & finally & for    \\
		from     & global & if      & import \\
		in       & is     & lambda  & not    \\
		or       & pass   & raise   & return \\
		try      & while  & with    & yield
	\end{tabular}
\end{center}

\section{Variables and assignment}
Python is dynamically typed language, it means it will decide what to do with your input at the run time.

Variable declaration and definition in python is something different. If you want to define integer in other languages, for that you follow this syntax \texttt{<data\textunderscore type> <variable\textunderscore name> = <value>}

In python you can directly assign value to the variable without specifying it's data type. Once you assign value to it Python interpreter will automatically parse it.
It's general syntax is: $<$variable1$>$...$<$variablen$>$ = $<$value1$>$...$<$valuen$>$
\begin{lstlisting}
>>> a = 10
>>> type(a)
<class `int'>
\end{lstlisting}
In above example you assigned \texttt{a = 10} and \texttt{type()} function shows it belongs to the \texttt{class int}.
Now let's assign \texttt{a = ``Hello''} and check it's type.
\begin{lstlisting}
>>> a = "Hello"
>>> type(a)
<class `str'>
\end{lstlisting}
In above example you could see that you can assign different value to same variable and interpreter accepted it.
\subsection{Indentation}
In python body of the statement is not defined by the curly brackets, you have to define body using indentations i.e. spaces.

If you are writing any statement, consider, if statement once you write if statement then you need to specify colon (:), then on the next line specify the spaces to define it's body.

\begin{lstlisting}
if ch == 1:
    print("You selected 1st choice")
\end{lstlisting}
For spaces you can either type 4 spaces or you can use tab. \\
NOTE: Mixture of both space and tabs will throw an exception.

\section{Conditional statements}
\subsection{If statement}
If statement is conditional statement. It is used to check the condition between two variables.

Any non zero value is considered as a True value. In python it's syntax is little bit different.

True keyword is used to represent boolean value. In first statement condition is true so it will print the if block. In second statement $ 10 > 10 $ condition is false, it will not print ``True statement".
\begin{lstlisting}
>>> if True:
...     print("True statement")
... 
True statement
>>> if 10>10:
...     print("True statement")
... 
>>> 
\end{lstlisting}

\subsection{if..else statement}
Like I mentioned in the above statement if is the conditional statement, in if statement if the condition is true, then it will execute the if block or it will skip it.

Here if condition is false then, else block got executed.
\begin{lstlisting}
>>> if False:
...     print("If block is printed")
... else:
...     print("Else block is printed")
... 
Else block is printed
>>> 
\end{lstlisting}


\subsection{if..elif statement}
In the python switch statement is not present. If you want to check any choice which is matches to the multiple statement then you need to use elif statement.

elif statement is check the condition, if the condition is true then it will execute the block or else block.

You can write as many elif statement as you want. But remember if one elif statement is executed it will not execute the remaining statement.

\begin{lstlisting}
>>> no = 10
>>> if no > 100:
...     print("no is grater")
... elif no < 10:
...     print("No is < 10")
... elif no == 10:
...     print("No is equal to 10")
... elif no == 10:
...     print("No is 10")
... else:
...     print("Unknown value of no")
... 
No is equal to 10
\end{lstlisting}

In above statement you can see that once the condition is true it skip the all the next elif statements.


\section{Loops}
In Python there are two main loops:
\begin{enumerate}
	\item For loop
	\item While loop
\end{enumerate}

\subsection{For loop}
For loop is basic loop. It is designed in such a way that it can iterate on the multiple objects.

Consider the following example:
\begin{lstlisting}
>>> for i in range(10):
...     print(i)
... 
0
1
2
3
4
5
6
7
8
9
>>>
\end{lstlisting}

In above example range is the inbuilt function which will return the list of the integer numbers from 0 to 9.

For loop by default pointing to zero location and printing the value.
In for loop values are auto increment.

\subsection{While loop}

While loop is used where for loop have limitations. One thing about the for loop it is basically used for iterating the objects. While loop is used to perform some mathematical operations or to perform some operations on user defined inputs etc.

\begin{lstlisting}
>>> i = 0
>>> while i < 10:
...     print(i)
...     i = i + 1
... 
0
1
2
3
4
5
6
7
8
9
>>> 
\end{lstlisting}

\subsection{Continue statement}
Continue statement is used to transfer the program execution back to the loop.

\begin{lstlisting}
>>> i = 0
>>> while i < 10:
...     i = i + 1
...     if i == 5:
...             continue
...     print(i)
... 
1
2
3
4
6
7
8
9
10
>>> 
\end{lstlisting}
In above example the control statement is forwarded to while loop again when condition is true. In output you can observe that it is not printed 5.

\subsection{Break statement}
Break statement is used to exit the loop. It's uses is same as continue statement.
\begin{lstlisting}
>>> i = 0
>>> while i < 10:
...     i = i + 1
...     if i == 5:
...             break
...     print(i)
... 
1
2
3
4
>>> 
\end{lstlisting}

\section{Strings}
In Python strings are defined using either ` quotes or `` quotes, but all of them treated as equally. When write a string it is a object of class \texttt{str}.
\begin{lstlisting}
>>> `hello' == "hello"
True
>>> type(`hello')
<class `str'>
\end{lstlisting}
If you specify \textbf{hello} without quotes then python interpreter will treat it as variable. If interpreter will find any variable then it will work otherwise it will throw an error.
\begin{lstlisting}
>>> hello
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'hello' is not defined
\end{lstlisting}
\subsubsection{String Methods}
You can check properties of string using \texttt{dir()} method.
\begin{lstlisting}
>>> dir('hello')
['__add__', '__class__', '__contains__', '__delattr__', 
'__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
'__getattribute__', '__getitem__', '__getnewargs__', 
'__gt__', '__hash__', '__init__', '__init_subclass__', 
'__iter__', '__le__', '__len__', '__lt__', '__mod__', 
'__mul__', '__ne__', '__new__', '__reduce__', 
'__reduce_ex__', '__repr__', '__rmod__', '__rmul__', 
'__setattr__', '__sizeof__', '__str__', '__subclasshook__',
'capitalize', 'casefold', 'center', 'count', 'encode',
'endswith', 'expandtabs', 'find', 'format', 'format_map',
'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit',
'isidentifier', 'islower', 'isnumeric', 'isprintable',
'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower',
'lstrip', 'maketrans', 'partition', 'replace', 'rfind',
'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split',
'splitlines', 'startswith', 'strip', 'swapcase', 'title',
'translate', 'upper', `zfill']
\end{lstlisting}
You can use the string properties using \texttt{.} symbol.
\begin{lstlisting}
>>> s = `Hello'
>>> s.upper()
HELLO
\end{lstlisting}
\subsection{Operation on strings}
\subsubsection{String Concatenation}
You can concat two string using \texttt{+} operator.
\begin{lstlisting}
>>> h = "Hello "
>>> i = "World"
>>> h + i
'Hello World'
\end{lstlisting}
\subsubsection{String Multiplication}
You can not subtract or divide string in Python. But you can multiply the strings with Python. When you multiply with the number it will create that strings references.
\begin{lstlisting}
>>> "Hello" * 5
`HelloHelloHelloHelloHello'
\end{lstlisting}
If you can multiply to the string with the numbers then it is easy to print star pattern in Python.
\begin{lstlisting}
>>> for i in range(1, 6):
...     print(`*' * i)
... 
*
**
***
****
*****
\end{lstlisting}
\subsubsection{Substring in String}
To check substring is present in the string is too much easy in the Python. You can use \texttt{in} keyword to check the substring is present or not.
\begin{lstlisting}
>>> s = "Incredible India!!"
>>> "India" in s
True
>>> "!!" in s
True
>>> "#" in s
False
>>> 
\end{lstlisting}
\subsection{Iteration on string}
You can iterate on the string using for loop. For loop automatically stops when string ended, you do not need to provide length of the string.
\begin{lstlisting}
>>> for i in 'hello':
...     print(i)
...
h
e
l
l
o
\end{lstlisting}
\subsection{String Slicing}
It will be more useful if strings are able to access using Python's array like syntax. Here in Python indexing is always starts with zero.\\
In python you can use -1, -2.. and so on to access the characters in the string, it will start accessing it from end of the string.
\begin{lstlisting}
>>> s = "Hello"
>>> s[0]
'H'
>>> s[-1]
'o'
\end{lstlisting}
Python will give you more easy syntax to access the string. In python you can access the strings with the following syntax.
\begin{lstlisting}
[start:stop:jump]
\end{lstlisting}
Start is from where you want to start accessing the string.\\
Stop is to where you want to stop accessing the string.\\
Jump is for jumping on the string.\\
Let's see few examples:
\begin{lstlisting}
>>> s[2:]   # It will print all the string from 2.
'llo'
>>> s[2:3]  # It will print string between index 2 to 3.
'l'
>>> s[:3]   # It will print the string till 3.
'Hel'
>>> s[::2]  # It will jump on the string.
'Hlo'
>>> s[-1:]  # It will print the string starting with o char.
'o'
>>> s[:-1]  # It will print the string expect last char.
'Hell'
>>> s[::-1] # It will reverse the string
'olleH'
\end{lstlisting}

\section{Lists}
Lists are the basic data structure in the Python. Lists are nothing but the array but they do not have fixed size, and they are heterogeneous. Lists can accept different type of elements.

You can define the lists using following ways:
\begin{lstlisting}
>>> l = []
>>> l1 = list()
\end{lstlisting}
Above statements will create the empty lists. Here \texttt{list} is the inbuilt method used for creating the list instance.

Again using \texttt{dir()} method you can check the properties of the lists.
If you want to add the element in to the empty list then you can use \textsc{append} method to add element in to list.
\begin{lstlisting}
>>> l.append(10)
>>> l
[10]
\end{lstlisting}
\subsection{List methods}
\begin{itemize}
	\item append(): To append element to the list.
	\item clear(): To clear the list.
	\item copy(): To copy the list in to the another variable. \footnote{ If we can directly copy one variable using assignment operator then why we need `copy' method?\\ Basically in python when assignment (=) operator, that time new variable just simply point to the list location.
		      \\
		      So if you change the list using old variable then new variable will reflect the change. But if you create new variable using copy(), then your new variable did not get affected.\\

	      }

	\item count(): Count the element occurrences in the list.
	\item extend(): To extend the existing list with another list. You can pass any object (string, list, dict, set) it will extend it to the list.
	\item index(): It will return index of the element.
	\item insert(): To insert the element at specific location. This method accepts two parameters, 1st one is index and 2nd is value.
	\item pop(): To pop the element from the list. By default it will remove the elements from the end of the list. If you want to remove the elements from any location then you can pass index at it.
	\item remove(): To remove the element from the list.
	\item reverse(): To reverse the list.
	\item sort(): To sort the elements in the list.
\end{itemize}
\clearpage


\subsection{Operation On Lists}
On lists you can perform different operations. You can add two lists. Ex:
\begin{lstlisting}
>>> l = [1, 2, 3]
>>> l1 = [4, 5, 6]
>>> l + l1
[1, 2, 3, 4, 5, 6]
\end{lstlisting}
You can multiply to list by number. It will create it's references but not the actual list.
\begin{lstlisting}
>>> [1] * 3
[1, 1, 1]
\end{lstlisting}
Elements in the lists can be checked using \texttt{in} keywords. It is same as checking the substring in string.
\begin{lstlisting}
>>> 1 in l
True
>>> 10 in l
False
\end{lstlisting}
\subsection{Iteration on Lists}
You can iterate on the list with for loop and using while loop.
\begin{lstlisting}
>>> l = [1, 2, 3]
>>> for i in l:
...     print(i)
... 
1
2
3
>>> i = 0
>>> while i < len(l):
...     print(l[i])
...     i += 1
... 
1
2
3
>>>
\end{lstlisting}
\subsection{List Slicing}
List slicing is same as string slicing. See the following few examples.
\begin{lstlisting}
>>> l
[1, 2, 3]
>>> l[0]
1
>>> l[:1]
[1]
>>> l[:2]
[1, 2]
>>> l[0:2]
[1, 2]
>>> l[0::2]
[1]
>>> l[::-1]
[3, 2, 1]
>>> 
\end{lstlisting}

\section{Tuples}
Tuples are same like lists. It is represent using round bracket $'('$ and $')'$.\\
Tuples are immutable objects, those can not be modified.
You can not update the value in the Tuple.
You can not add or remove the elements in the Tuple.
\begin{lstlisting}
>>> t = tuple()
>>> t
()
>>> t = (10, 20, 30)
>>> t
(10, 20, 30)
>>>
\end{lstlisting}
\subsubsection{Tuple methods}
You can check the properties of the Tuples using \textbf{dir} method. You will find only two properties.
\begin{itemize}
	\item count(): It will give you the count of the elements in the tuple.
	\item index(): It will give you the index of the element.
\end{itemize}
\subsubsection{Operations on Tuples}
As we saw in the lists, you can add two Tuples. Ex:
\begin{lstlisting}
>>> t
(10, 20, 30)
>>> t + t
(10, 20, 30, 10, 20, 30)
>>>
\end{lstlisting}
You can multiply the Tuple by number. It will create it's references, but not the actual list.
\begin{lstlisting}
>>> t * 3
(10, 20, 30, 10, 20, 30, 10, 20, 30)
\end{lstlisting}
\subsubsection{Iteration on Tuples}
You can iterate on the list using for loop and while loop.
\begin{lstlisting}
>>> for i in t:
...     print(i)
... 
10
20
30
>>> i = 0
>>> while i < len(t):
...     print(t[i])
...     i += 1
... 
10
20
30
>>> 
\end{lstlisting}
\subsubsection{Tuple Slicing}
You can perform slicing operations on the lists. See following few examples:
\begin{lstlisting}
>>> t[0]
10
>>> t[:2]
(10, 20)
>>> t[2:5]
(30, 40, 50)
>>> t[4:]
(50, 60, 70)
>>> t[4::-1]
(50, 40, 30, 20, 10)
>>> t[::2]
(10, 30, 50, 70)
>>> 
\end{lstlisting}
\section{Dictionaries}
Dictionaries are based on the hash tables data structure in C. Dictionaries are defined using key and value. You can use curly braces ${}$ to define the dictionaries.

Dictionaries are based on key and values. For each value there is one  key associated with it.
\begin{lstlisting}
>>> d = {}
>>> d = {'country': 'India', 
...      'capital': 'Delhi', 
...      'states': 29}
>>> d
{'country': 'India', 'capital': 'Delhi', 'states': 29}
\end{lstlisting}
You can access the values using associated keys, and you can replace it using simple way.
\begin{lstlisting}
>>> d['states']
29
>>> d['states'] = 30
>>> d
{'country': 'India', 'capital': 'Delhi', 'states': 30}
>>> d['Languages'] = ['Hindi', 'English', 'Tamil', 'Malyalum',
 'Marathi', 'Gujarati']

\end{lstlisting}
Keys in the dictionary are anything those can be string, integer, floating point values or any module object.
\begin{lstlisting}
>>> import os
>>> d = {}
>>> d[os] = 'os'
>>> d[1] = 'One'
>>> d['two'] = 2
>>> d[3.3] = 'three.three'
>>> d
{<module 'os' from '/usr/lib64/python3.6/os.py'>: 'os', 1: 'One', 'two': 2, 3.3: 'three.three'}
\end{lstlisting}
\subsection{Dictionary Methods}
Dictionary have following methods:
\begin{itemize}
	\item clear() : To clear the dictionary.
	\item copy() : To copy the dictionary to the another variable.
	\item get() : Get is used for getting the value of the specific key in the dictionary or it will return \texttt{None}.
	\item items() : This method will return the all the items in the dictionary inside the list. This list will consist the pair of the key and value tuple.
	\item keys() : This method will return all the keys inside the dict.
	\item pop() : This method will pop specified key and return the value.
	\item popitem(): This method will pop any random key and value from they dictionary, it will return the tuple of key and value.
	\item update(): This method will update the dictionary with new values or old keys with new values.
	\item values() : This method will return the list of the all values.
	\item fromkeys() : This method will return the new dictionary with keys from iterable and values equal to values.
\end{itemize}
\subsection{Iteration on Dictionary}
You can iterate on the dictionary using the for loop. By default it will iterate on the keys.
\begin{lstlisting}
>>> d = {'one' : 1, 'two': 2, 'three': 3}
>>> for i in d:
...     print(i)
... 
one
two
three
>>> 
\end{lstlisting}
In the dictionary you can iterate only values. For that you need to use \texttt{values()} method.
\begin{lstlisting}
>>> for i in d.values():
...     print(i)
... 
1
2
3
>>> 
\end{lstlisting}
Using the beauty of the for loop you can iterate on the key and value  at the same time. For that you can use \texttt{items()} method.
\begin{lstlisting}
>>> for i, j in d.items():
...     print(i, j)
... 
one 1
two 2
three 3
>>> 
\end{lstlisting}

\section{Functions}
Function is a block of statements which will perform single action. Function will provide modular code, which will be more easy to read. You can reuse this code to perform some action which will save your time.

In Python you can define the function using the \texttt{def} keyword.
After the def keyword you define the name of the function and later in the parenthesis you provide the arguments, after the arguments line ends with the \texttt{$:$} which indicate that from the next line body of the function will be begin.
\begin{lstlisting}
>>> def add():
...     print("Addition : ", 10 + 20)
... 
>>> add()
Addition : 30
\end{lstlisting}
Above code will show the simple example of the function. This add function will print the addition of the two numbers. You can call any function using \texttt{function\textunderscore name$($args$)$} syntax, for Ex. \texttt{add()} in above code.

In Python you can return the values from the function using \texttt{return} keyword. Below code shows some example of the function with with return values.
\begin{lstlisting}
>>> def add():
...     return 10+20
... 
>>> add()
30
>>> t = add()
>>> t
30
>>> def add():
...     return 10+20
... 
>>> def sub():
...     print(20 - 10)
... 
>>> 
>>> u = sub()
10
>>> print(u)
None
>>> 
\end{lstlisting}
In above example add function will return the value, which is addition of the two numbers. You can store that value in a variable for later use.
\paragraph{}
Let's see other side, what if function do not return any value? In that case it will return \texttt{None} keyword. You can see the example in above code with function sub. Function will print the subtraction but it will not return anything. By default the value is \texttt{None}.
\subsection{Functions with arguments}
In functions arguments can be passed, In function you can pass $n$ no of arguments. To pass the arguments in the function you do not need to specify the data type, which we specify in C, C++ or Java. As mentioned earlier, Python is dynamic language.
\begin{lstlisting}

>>> def add(a, b):
...     return a + b
... 
>>> add(109, 23)
132
>>> add("abc", "def")
'abcdef'
>>> add([1], [2])
[1, 2]
>>> add(109)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: add() missing 1 required positional argument: 'b'
>>> add()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: add() missing 2 required positional arguments: 'a' and 'b'
\end{lstlisting}
In above program, two arguments are passed (a and b) to the function, and it is not defined with the data types. That means you can pass anything in the function call. You can pass integer or you can pass list or you can pass list.
\paragraph{}
If you are not passing expected arguments to the function then function will throw an error.

\subsection{*args and **kwargs in Function}
*args and **kwargs are play major role in function arguments. Consider if you want to pass $n$ no of arguments in to the function, some languages have restrictions on that, you can pass the arguments which are defined in the function. But Python gives you more scope to pass the $n$ no of arguments to the function.

\begin{itemize}
	\item **args used for the passing $n$ no of positional arguments tot the function.
	      \begin{lstlisting}
>>> def add(*args):
...     return sum(args)
... 
>>> 
>>> add(10, 20, 30, 40, 50, 60)
210
>>> 
\end{lstlisting}
	      *args accept all the arguments in to the tuple.
	\item **kwargs used for the passing $n$ no of key and value based arguments to the function.
	      \begin{lstlisting}
>>> def details(**kwargs):
...     print(kwargs)
... 
>>> 
>>> details(name='John',surname='Doe',age=10,height=5.5)
{'name': 'John', 'surname': 'Doe', 'age': 10, 'height': 5.5}
\end{lstlisting}
	      **kwargs accepts all the arguments in to the dictionary.
\end{itemize}

\section{Decorators}
Decorators are the functions, which take function as input argument. You can decorate any functions with decorators and change the functionality of the function.
\paragraph{}
To understand the Decorators in deep, let's revisit functions once more. Now you know that how to define function and how to call it. But what if you didn't call it and just wrote the name?
\begin{lstlisting}
>>> def add(a, b):
...    return a + b
...
>>> add
<function add at 0x7f566467d0d0>
\end{lstlisting}

Yes.. it will show you address of that function. It is telling you that function is present at some location on memory. If you will get address of that function then you can play around it.
\paragraph{}
Remember we did not called the function yet, we just print it's memory location. If that is the case then we can pass this function as an argument to another function (like call by reference in C).

\begin{lstlisting}
>>> def wrapper(func):
...     print("Before func")
...     print(func(10, 20))
...     print("After func")
... 
>>> wrapper(add)
Before func
30
After func
>>> 
\end{lstlisting}
In above example, I wrote another function name as 'wrapper' and passed one argument 'add' in it, and inside the wrapper function I called function 'func' with two parameters.
After hitting enter, we could see that function add print addition 30 in between 'Before func' and 'After func'.
\paragraph{}
So basically this happened, I passed 'add' to 'wrapper' and when wrapper get called it printed "Before func" then it will call 'add' function which takes two arguments and return and print the result, After that it will print "After func". So this passed add function is get called within the 'wrapper' function.
\paragraph{}
Python allows us to decorate the functions using decorator, so we can write the code like this
\begin{lstlisting}
>>> def wrapper(func):
...     print("Before func")
...     func()
...     print("After func")
... 
>>> @wrapper
... def hello_world():
...     print("Hello World")
... 
Before func
Hello World
After func
>>> 
\end{lstlisting}

When you decorate any function, by default python interpreter call wrapper function add pass "hello\textunderscore world" function reference in to it.
\paragraph{}
Basically we can write above decorator function in simple form
\begin{lstlisting}
>>> def wrapper(func):
...     print("Before func")
...     func()
...     print("After func")
...
>>> @wrapper
... def hello_world():
...     print("Hello World")
...
Before func
Hello World
After func
\end{lstlisting}
Okay.. now I expect you got some understanding of the decorators. You might have notice that it get called automatically by the interpreter.

\section{Exception Handling}
In Python there are multiple built in exceptions are present. Exceptions are designed to handle the error in running program. Consider if you are converting the strings to the integer, which is against the Python programming language rule. To handle this situation exceptions are used. If exceptions are not used then program will crash.
\paragraph{}
In Python exceptions are defined using \texttt{try},\texttt{except}, \texttt{finally} and \texttt{else} keywords. In the \texttt{try} block you can write your code, if you know that this will cause an error then you can write that in to the \texttt{try} block. To handle the error you can write your error message in to the \texttt{except} block.
\paragraph{}
Once error occur in \texttt{try} block then control passes to the \texttt{except} block and continues the program execution.
\begin{lstlisting}
try:
    int("abc")
except:
    print("Error occured")

print("Hello")
\end{lstlisting}

Let's consider the another example, If you want use should insert proper integer value then you should write it using following way. This program will run until user will not provide the integer value.
\begin{lstlisting}
while True:
    val = input("Enter Value: ")
    try:
        int(val)
        break
    except:
        print("Invalid value inserted.")
        continue

print("Hello")
$ python3 /tmp/exception.py
Enter Value: abc
Invalid value inserted.
Enter Value: 123sad
Invalid value inserted.
Enter Value: 123
Hello
\end{lstlisting}

In Python multiple exceptions are present, those exception are used with specific conditions, You will use \texttt{ValueError} exception when convert the string value to integer.
\begin{lstlisting}
d = {1:'abc'}

while True:
    val = input("Enter Value: ")
    try:
        int(val)
        d[int(val)]
        break
    except ValueError:
        print("Invalid value inserted.")
    except KeyError:
        print("Key is not available in dict")

print("Hello")
\end{lstlisting}
In above program if you provide another value expect digits then you will get value error. If you provide the any digit except 1 then it will throw an key error.

Exception is generic class, if you don't know which error will occur then you will write Exception class and print it.
\begin{lstlisting}
d = {1:'abc'}

while True:
    val = input("Enter Value: ")
    try:
        int(val)
        d[int(val)]
        break
    except Exception as e:
        print(e)
        print("Error occured")

print("Hello")
\end{lstlisting}
\section{Class}
Class is nothing but the group of the methods and variables. Classes are the basic building block of Object Oriented programming.
\paragraph{}
In Python you can define the classes using $class$ keyword. Inside the class you can define the methods which are class methods. To define the methods are related to the class, first argument passed is $self$, it tells the compiler this method is class method. That means you can not access this method without creating it's object.

\begin{lstlisting}
>>> class math_op():
...     def get_add(self, a, b):
...             return a + b
... 
>>> 
\end{lstlisting}
\subsection{Objects}
Objects are the instance of the class. You can create the object of the class with giving the class reference. Once you created the object you can access class methods using $(.)$.

\begin{lstlisting}
>>> m = math_op()
>>> m.get_add(10, 20)
30
>>>
\end{lstlisting}
\subsection{Constructors}
\subsubsection{Default Constructors}
Constructors are the methods which are called when the objects are created. In Python you can defined the constructors, which get called when object got created.

\begin{lstlisting}
class math_op():
    def __init__(self):
        print("Init is called")

m = math_op()
\end{lstlisting}
In above program $m$ is the object which we created of the class $math \textunderscore op$. As soon as object got created that time $\textunderscore\textunderscore init\textunderscore\textunderscore()$ method got called.
If you run the above program, then it will give an output like:
\begin{lstlisting}
Init is called
\end{lstlisting}
\subsubsection{Parametrize Constructors}
In parametrize constructors you can pass the parameters to the constructor, it is need to pass when we create the object of the class.

\begin{lstlisting}
class math_op():
    def __init__(self, a, b):
        print(a, b)
        print("Init is called")
		
m = math_op(10, 20)
\end{lstlisting}
If you run the above program it will show output like
\begin{lstlisting}
10 20
Init is called
\end{lstlisting}
\subsection{Magic Methods}
In Python there are class method which are inbuilt, those methods can be overwrite, and those methods are known as Magic methods.
\paragraph{}
Magic methods are the methods which are used to play with the object. Recently we saw one example of Magic methods which is $\textunderscore\textunderscore init \textunderscore\textunderscore()$.

Earlier we saw that we can add two objects like int, str, list etc... Now let's implement it.
\begin{lstlisting}
>>> class Human():
...     def __init__(self, name):
...             self.name = name
...     def __add__(self, obj):
...             return self.name + " " + obj.name
... 
>>> h = Human("Jon")
>>> h1 = Human("Doe")
>>> h + h1
'Jon Doe'
>>> 
\end{lstlisting}
In above example we created one class and override the $\textunderscore\textunderscore add \textunderscore\textunderscore()$ magic method. This method will get called when we are going to add two objects. When we created the objects $h$ and $h1$ that time they are the objects of the same class. So we know that both of them have the same properties. Now let's add them.

\paragraph{}
When we are adding them first object's $add$ method get called and by default constructor will pass $h1$ object as $obj$ in the add method of the Human class.

Using the same way you can override the other methods too:
\begin{itemize}
	\item  $\textunderscore\textunderscore add \textunderscore\textunderscore()$ Add two objects
	\item  $\textunderscore\textunderscore sub \textunderscore\textunderscore()$ Subtract two objects
	\item  $\textunderscore\textunderscore mul \textunderscore\textunderscore()$ Multiply two objects
	\item  $\textunderscore\textunderscore div \textunderscore\textunderscore()$ Divide two objects
	\item  $\textunderscore\textunderscore lt \textunderscore\textunderscore()$ check less than condition $ a < b$
	\item  $\textunderscore\textunderscore gt \textunderscore\textunderscore()$ Check grater than condition $ a > b$
	\item  $\textunderscore\textunderscore le \textunderscore\textunderscore()$ Check less than and equal to condition $ a <= b$
	\item  $\textunderscore\textunderscore ge \textunderscore\textunderscore()$ Check grater than and equal to condition $a >= b$
	\item  $\textunderscore\textunderscore repr \textunderscore\textunderscore()$ Object representation on the console.
	\item  $\textunderscore\textunderscore str \textunderscore\textunderscore()$ Object representation when we are using $print()$
	\item  $\textunderscore\textunderscore len \textunderscore\textunderscore()$ To Count the length of the object. (Uses with $len()$)
	\item  $\textunderscore\textunderscore dir \textunderscore\textunderscore()$ Return the methods associated with the class. (Uses with $dir()$)
\end{itemize}
\section{Inheritance}
\section{File Operations}
\section{Modules}
Implementing modules in Python is very easy. Modules are nothing but the file with the class. If you want to use those classes then you can directly import those classes in your code.
Let's create on file wich has 2 classes. Class A has get\_a and set\_a methods and Class B has get\_b and set\_b methods.

\begin{lstlisting}
  class A:
      a = 10
      def get_a(self):
          return self.a

      def set_a(self, a):
          self.a = a
          
  class B:
      b = 20
      def get_b(self):
          return self.b

\end{lstlisting}

\subsection{sys module}
sys module is used to check the which type of system it is, This module gives you the details about the system, consider you don't know which OS you have Mac OS, Linux OS and Windows, you can find out it using sys module.
\begin{lstlisting}
>>> import sys
>>> sys.platform
'linux'
>>> sys.version
'3.6.6 (default, Jul 19 2018, 14:25:17) \n[GCC 8.1.1 20180712 (Red Hat 8.1.1-5)]'
>>> sys.getdefaultencoding()
'utf-8'
>>> sys.getrecursionlimit()
1000
\end{lstlisting}
\subsection{os module}
os module is in built module in the python. Using this module you can perform OS related tasks, like listing directory, create directory, traverse directory.
\begin{lstlisting}
>>> import os
>>> # os.listdir() listing the files in the specific directory
... # os.path : This class provides methods to deal with path in Linux.
... # os.walk : This will iterate on the directory and will return directory, subdir, files.
... # os.getcwd() : Will show current working directory
... # os.system() : which will execute the shell commands
... # os.getuid() : It will return the UID of the current user.
... # os.mkdir() : To create the directory
... # os.makedirs(): To create nested directory recursively.
... # os.rmdir() : To remove single directory.
... # os.removedirs(): To remove nested directory recursively.
\end{lstlisting}
\subsection{re module}
\subsection{sqlite module}
\section{Python Built In methods}
Python as language it has some of it's features. It imports some of the functions and variables by default, So you don't need to call modules to execute this function. Well this is perfect match for 'Beautiful is better than Ugly' from Zen of Python.
\paragraph{}
Python has some of the 'builtins' methods and classes which are imported by default. Open interpreter and type dir\(\textunderscore \textunderscore biltins \textunderscore \textunderscore\).
\begin{lstlisting}
>>> dir(__builtins__)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
\end{lstlisting}
You could see the list of the 'builtin' Exception and methods. If you want to execute those methods and Execption you can directly call them in the interpreter.
Like we used 'print' before and list, dict, range etc.
\paragraph{}
All those are coming form the builtin module. And by default this module is assigned to the \textunderscore \textunderscore builtin \textunderscore \textunderscore.
Let's check that out.
\begin{lstlisting}
>>> import builtins
>>> id(builtins)
139815372774672
>>> id(__builtins__)
139815372774672
\end{lstlisting}
Yes.. id of the both are same. You can try to import from 'builtins' and run it will return the same result.
\paragraph{}
All the list items are starting with Capital letters are the Exceptions. And rest are the methods.
\part{Testing with Python}
\part{Django}
\end{document}
